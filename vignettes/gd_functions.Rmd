---
title: "Grouped Data Functions"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{gd_functions}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(pipster)
```

## Overview

This vignette shows an overview of the `pipster` package functions for grouped data. Grouped data are consumption expenditure or income organized in intervals or bins, such as deciles or percentiles. In order to estimate poverty and inequality measures from grouped data, one has to derive a continuous Lorenz curve and use it together with mean welfare to build a full distribution.
`pipster` provides a series of functions to estimate poverty and inequality measures, based on the methodology of [Datt (1998)](http://ebrary.ifpri.org/utils/getfile/collection/p15738coll2/id/125673/filename/125704.pdf):

-   `pipgd_pov_headcount()` (FGT0)

-   `pipgd_pov_gap()` (FGT1)

-   `pipgd_pov_severity()` (FGT2)

It also provides a series of functions to calculate distributional measures and to select and validate the best Lorenz curve for subsequent estimation:

-   `pipgd_welfare_share_at()`

-   `pipgd_quantile_welfare_share()`

-   `pipgd_quantile()`

-   `pipgd_validate_lorenz()`

-   `pipgd_select_lorenz()`

## Sample Grouped Data
In this vignette, we will explore several typical scenarios in which the pipster package can be effectively utilized. In each of these scenario, we will use a sample dataset, `pip_gd`, available with the package and obtained from [Datt (1998)](http://ebrary.ifpri.org/utils/getfile/collection/p15738coll2/id/125673/filename/125704.pdf). The dataset shows the distribution of consumption expenditure in rural India in 1983. The variables are the following:

  * **W**: Weights, share of population, sum up to 100.
  * **X**: Welfare vector with mean welfare by group.
  * **P**: Cumulative share of population.
  * **L**: Cumulative share of welfare.
  * **R**: Share of welfare, sum up to 1.

```{r data, echo=FALSE}
pip_gd |>
  print()
```

## Case 1: Simple Welfare Analysis and Lorenz Curve
### 1.1 Welfare share at a given population share
One simple use case is calculating the welfare share of a specific share of the population, which can be achieved using `pipgd_welfare_share_at()`:
```{r popshare}
# Calculate the welfare share at a given population share
selected_popshare <- 0.5
welfare_share_50 <- pipgd_welfare_share_at(welfare = pip_gd$L,
                                           weight = pip_gd$P,
                                           popshare = selected_popshare,
                                           complete = FALSE)
```

When `complete = FALSE`, the output is a list. The results can be accessed like so:
```{r popshare-results}
# Format the string with the given values
formatted_message <- sprintf("%.0f%% of the population owns %.0f%% of welfare.",
                             selected_popshare * 100,
                             welfare_share_50$dist_stats$welfare_share_at[[1]] * 100)

print(formatted_message)
```
### 1.2 Quantile share vs cumulative share
`pipster` has a selection of functions to calculate welfare shares. When `n` is declared, `pipgd_quantile_welfare_share()` will calculate the share of welfare owned by a specific share of the population, while `pipgd_welfare_share_at()` will return the cumulative share:

```{r quantile-vs-cumulative}
quantile_welfare_share <- pipgd_quantile_welfare_share(welfare = pip_gd$L,
                                                       weight = pip_gd$P,
                                                       n = 5,
                                                       complete = FALSE)
quantile_welfare_share_at <- pipgd_welfare_share_at(welfare = pip_gd$L,
                                                    weight = pip_gd$P,
                                                    n = 5,
                                                    complete = FALSE)

# Combine into a dataframe for practicality
df_combined <- data.frame(
  popshare = quantile_welfare_share$dist_stats$popshare,
  quantile_share = quantile_welfare_share$dist_stats$quantile_welfare_share,
  cumulative_share = quantile_welfare_share_at$dist_stats$welfare_share_at
)

# View the combined dataframe
print(df_combined)

```
### 1.3 Estimate and Plot the Lorenz Curve
`pister` can also be used to estimate a Lorenz curve for a dataset of grouped data. One hypothetical workflow:

  1. First, generate the parameters using `pipgd_params()`
  2. Validate the parameters using `pipgd_validate_lorenz()`
  3. Generate the Lorenz curve using the validated parameters with `pipgd_lorenz_curve()`

```{r lorenz-validate}
# Validate Lorenz curve.
parameters <- pipgd_params(welfare = pip_gd$L,
                           weight = pip_gd$P)
validated_lorenz <- pipgd_validate_lorenz(params = parameters,
                                          complete = TRUE)

# Select the best Lorenz curve and check which method has been used.
selected_lorenz <- pipgd_select_lorenz(params = validated_lorenz)
lorenz_used_for_dist <- selected_lorenz$selected_lorenz$for_dist
lorenz_used_for_pov <- selected_lorenz$selected_lorenz$for_pov

formatted_message <- sprintf("%s used for distribution statistics and %s used for poverty metrics.",
                             lorenz_used_for_dist,
                             lorenz_used_for_pov)

print(formatted_message)
```


```{r lorenz-plot}
# Plot the Lorenz Curve
lorenz_curve_data <- pipgd_lorenz_curve(params = validated_lorenz)
plot(lorenz_curve_data$lorenz_curve$points,
     lorenz_curve_data$lorenz_curve$output,
     type = 'l', col = 'blue',
     xlab = 'Cumulative Share of Population',
     ylab = 'Cumulative Share of Welfare',
     main = 'Lorenz Curve',
     xlim = c(0, 1), ylim = c(0, 1),
     xaxs = "i", yaxs = "i")

# Add the line of equality
abline(0, 1, col = 'red', lty = 2)
```


## Case 2: Poverty Profiling
### 2.1 Poverty Headcount
First, we can apply the `pipgd_pov_headcount()` function to determine the proportion of the population living below a specified poverty line. According to Datt(1998), the 
rural poverty line for India in 1983 is Rs. 89:

```{r headcount}
poverty_line <- 89 
headcount1 <- pipgd_pov_headcount(welfare = pip_gd$L, 
                                 weight = pip_gd$P, 
                                 povline = poverty_line)
poverty_line <- c(89) 
headcount2 <- pipgd_pov_headcount(welfare = pip_gd$L, 
                                 weight = pip_gd$P, 
                                 povline = poverty_line,
                                 mean = 109.9,
                                 times_mean = 10)

print(headcount1, headcount2)

```


## Case 3:
