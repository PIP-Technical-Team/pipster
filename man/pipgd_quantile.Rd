% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pipgd_dist.R
\name{pipgd_quantile}
\alias{pipgd_quantile}
\title{Get quantile at specified shared of population - grouped data}
\usage{
pipgd_quantile(
  params = NULL,
  welfare = NULL,
  weight = NULL,
  n = 10,
  popshare = seq(from = 1/n, to = 1, by = 1/n),
  mean = 1,
  complete = getOption("pipster.return_complete"),
  lorenz = NULL
)
}
\arguments{
\item{params}{list of parameters from \code{pipgd_validate_lorenz()}}

\item{welfare}{numeric vector of cumulative share of welfare (income/consumption)}

\item{weight}{numeric vector of cumulative share of the population}

\item{n}{numeric scalar for the number of quantiles to be used in \code{popshare}}

\item{popshare}{numeric: vector of share of population. Default is \code{seq(from = 1/n, to = 1, by = 1/n)}}

\item{mean}{numeric scalar of distribution mean. Default is 1}

\item{complete}{logical: If TRUE, returns a list a cumulative returns from
previously used \code{get_gd} functions. Default is \code{FALSE}}

\item{lorenz}{character or NULL. Lorenz curve selected. It could be "lq" for
Lorenz Quadratic or "lb" for Lorenz Beta}
}
\value{
Returns a nested list containing distribution statistics:
\verb{$dist_stats$pop_share} is a numeric vector containing the share of the
population.
\verb{$dist_stats$quantile} is a numeric vector showing the
corresponding quantile.
If \code{complete = TRUE}, it returns a \code{pipgd_params} object with additional
details and intermediate calculations.
}
\description{
\code{pipgd_quantile} returns the quantile (i.e., monetary value) that corresponds
to the share of the population that lives below that threshold.
}
\details{
This is basically the inverse of estimating the poverty rate (headcount or
population share) below the poverty line. In this case, you provide the
headcount and \code{pipgd_quantile} returns the "poverty line".

The quantiles are calculated as function of the mean of the distribution
times an \code{x} factor. Basically, the quantile is \code{x} times the mean. By
default, the mean is equal to 1, which implies that, if no mean value is
provided, the return value is equal to \code{x}.

\strong{NOTE:} the outcome from \code{pipgd_quantile} is not necessarily the inverse
of \link{pipgd_pov_headcount}. The reason for this is that, \link{pipgd_pov_headcount}
selects the Lorenz parametrization that fits better at that specified point
of the distribution (i.e., the poverty lines). \link{pipgd_quantile}, in contrast,
use the same Lorenz parametrization for any point. The lorenz used is the one
that fits best for all distributional measures.
}
\examples{
# Example 1: Basic usage with default parameters
quantile_default <- pipgd_quantile(welfare = pip_gd$L,
                                   weight  = pip_gd$P)

# Example 2: Specifying a custom number of quantiles
quantile_custom <- pipgd_quantile(welfare = pip_gd$L,
                                  weight  = pip_gd$P,
                                  n       = 5)

# Example 3: Using a custom population share vector
custom_popshare_vector <- c(0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.4, 0.5, 0.6,
0.7, 0.8, 0.9, 0.95)
quantile_custom_shares <- pipgd_quantile(welfare = pip_gd$L,
                                         weight  = pip_gd$P,
                                         popshare = custom_popshare_vector)

# Example 4: Specifying a different Lorenz curve ('lb', Lorenz beta)
quantile_lorenz_beta <- pipgd_quantile(welfare = pip_gd$L,
                                       weight  = pip_gd$P,
                                       lorenz  = "lb")


# Example 5: Detailed output with complete = TRUE and different mean factor
quantile_detailed <- pipgd_quantile(welfare = pip_gd$L,
                                    weight  = pip_gd$P,
                                    mean = 1.5,
                                    complete = TRUE)

}
